/***************************************************************************************************
**    Copyright (C) 2016-2017 HMS Technology Center Ravensburg GmbH, all rights reserved
****************************************************************************************************
**
**        File: spduIn.c
**     Summary: This module provides functions to take the sub frames (incomplete IO Data Messages,
**              Time Coordination Messages) generated by CSS and exchange them via IPC.
**              The target is to generate a valid IO Data Message and/or Time Coordination Message
**              which can be sent inside the SPDU part of the AIC telegram.
**   $Revision: 3166 $
**       $Date: 2017-05-31 14:41:15 +0200 (Mi, 31 Mai 2017) $
**      Author: K.Angele
** Responsible: (optional)
**
****************************************************************************************************
****************************************************************************************************
**
**  Functions: spduIn_Init
**             spduIn_BuildTgm
**             spduIn_BuildTgmDummy
**             spduIn_ResetTgmIo
**             spduIn_ResetTgmTcco
**             spduIn_SendSafeTgm
**             spduIn_RecvSafeTgm
**             spduIn_PrepIpcIo
**             spduIn_PrepIpcTcoo
**             setTgmTcoo
**             setTgmIo
**
**    History:
**
****************************************************************************************************
**    Template Version 5
***************************************************************************************************/


/***************************************************************************************************
**    include-files
***************************************************************************************************/

/* system includes */
#include "xtypes.h"
#include "xdefs.h"

#include "globPreChk.h"
#include "globFail_Errorcodes.h"
#include "cfg_Config-sys.h"
#include "globFail_SafetyHandler.h"
#include "rds.h"

#include "ipcx_ExchangeData-sys_def.h"
#include "ipcx_ExchangeData-sys.h"

#include "stdlib-hal.h"

/* application includes */
#include "aicMsgDef.h"
#include "spduIn.h"


/***************************************************************************************************
**    global variables
***************************************************************************************************/

/* spduIn_s_Paket:
** location/array to store the outgoing safe packet (safety module to safe PLC),
** global used due to performance reasons,
** Formerly aicDataStackSpdu_sTxSpduInPaket
*/
AICMSGDEF_SPDU_TX_STRUCT spduIn_s_Paket;


/***************************************************************************************************
**    static constants, types, macros, variables
***************************************************************************************************/
   
   /* Unique file id used to build additional info */
#define k_FILEID      27u

/* Length of Data Message sub frame transferred via IPC */
#define k_IODATA_MSG_IPC_LEN   (AICMSGDEF_CIP_IN_DATA_SIZE  / 2u)
/* Length of Time Coordination sub frame transferred via IPC */
#define k_TCCO_MSG_IPC_LEN     (AICMSGDEF_CIP_IN_DATA2_SIZE / 2u)
   
   
/* t_SAFETGM_IPC:
** Data structure used for IPC exchange of CIP Safety subframes 
*/
typedef struct 
{
  UINT8  u8_dataTgmCnt;
  UINT8  u8_dataTgm[k_IODATA_MSG_IPC_LEN];
  UINT8  u8_tcooTgmCnt;
  UINT8  u8_tcooTgm[k_TCCO_MSG_IPC_LEN];
} t_SAFETGM_IPC;


/** PRE-PROCESSOR CHECK **/
/* This module expects the IO Data Message size of 14 bytes and the 
** Time Coordination Message size of 6 byte. No generic approach because
** of performance reasons.
*/
/* Deactivated Lint Note 948: Operator '==' always evaluates to True */
/*lint -e(948) */
#ifdef RFID_ACTIVE
IXX_TASSERT((AICMSGDEF_CIP_IN_DATA_SIZE  == 14u + (4u * 2)), spduIn_chk1)
#else
IXX_TASSERT((AICMSGDEF_CIP_IN_DATA_SIZE  == 14u), spduIn_chk1)
#endif
/*lint -e(948) */
IXX_TASSERT((AICMSGDEF_CIP_IN_DATA2_SIZE == 6u),  spduIn_chk2)

/* Mute lint warning type not referenced. These types are just defined for    */
/* being able to do some elementary checks. */
/*lint -esym(751, IXX_DUMMY_spduIn_chk1) not referenced - just for checks */
/*lint -esym(751, IXX_DUMMY_spduIn_chk2) not referenced - just for checks */


/* u8_LastSentIoDui:
** Variable indicates the Update Indicator of the last sent IO Data Message
*/
STATIC RDS_UINT8 u8_LastSentIoDui;

/* u8_LastSentTccoDui:
** Variable indicates the Update Indicator of the last sent Time Coordination Message
*/
STATIC RDS_UINT8 u8_LastSentTccoDui;

/* u8_SubframeTcooDui:
** Data Update Indicator of Time Coordination Message subframe, RDS variable
** The variable is incremented if a new Time Coordination Message was generated
** by CSS.
*/
STATIC RDS_UINT8 u8_SubframeTcooDui;

/* u8_SubframeIoDui:
** Data Update Indicator of IO Data Message subframe, RDS variable
** The variable is incremented if a new IO Data Message was generated
** by CSS.
*/
STATIC RDS_UINT8 u8_SubframeIoDui;
   
/* s_SafeTgmIpcRx:
** Subframes received from other controller to build new CIP Safety Messages. 
*/
STATIC t_SAFETGM_IPC s_SafeTgmIpcRx;

/* s_SafeTgmIpcTx: 
** Subframes sent to other controller to build new CIP Safety Messages. 
*/
STATIC volatile t_SAFETGM_IPC s_SafeTgmIpcTx;

/* u32_IoDataAddInfoTx:
** Additional info used for IO Data Message
*/
STATIC volatile UINT32 u32_IoDataAddInfoTx = 0u;

/* u32_TcooAddInfoTx:
** Additional info used for Time Coordination Message
*/
STATIC volatile UINT32 u32_TcooAddInfoTx   = 0u;

/***************************************************************************************************
**    static function-prototypes
***************************************************************************************************/

STATIC void setTgmTcoo(void);
STATIC void setTgmIo(void);

/***************************************************************************************************
**    global functions
***************************************************************************************************/

/***************************************************************************************************
  Function:
    spduIn_Init

  Description:
    This function is used to initialize the module.

  See also:
    -

  Parameters:
    -

  Return value:
    -

  Remarks:
    Context: main (during initialization)

***************************************************************************************************/
void spduIn_Init(void)
{

  /* Attention: Function called before IRQ Scheduler started. So disabling IRQ (before accessing
  ** variables) is not necessary here. */

  /* init RDS variables of the module */
  RDS_SET(u8_LastSentIoDui, 0u);
  RDS_SET(u8_LastSentTccoDui, 0u);
  RDS_SET(u8_SubframeTcooDui, 0U);
  RDS_SET(u8_SubframeIoDui, 0U);
}

/***************************************************************************************************
  Function:
    spduIn_BuildTgm

  Description:
    The main function is to build the safe packet according to the safety protocol specification.
    For this purpose the functions takes the safe fragment build by the own controller and the 
    fragment build by the other controller and generates the safety packet. So it is ensured that
    a safety packet is never build by only one controller (see [SRS_2030]). The fragments are 
    exchanged via IPC previously. 
    Because it is possible, that one controller was able to build a fragment but the other 
    controller not, the DUI (Data Update Indicator) is used to detect if both controllers have 
    exchanged the same frame fragment. If the DUI is different, the safe packet is NOT build. 
    That means in that case the old data is transferred again to AM.

  See also:
    -

  Parameters:
    -

  Return value:
    -

  Remarks:
    Context: IRQ Scheduler

***************************************************************************************************/
void spduIn_BuildTgm (void)
{
   /* HALC messages sent from T100 to ABCC (IO Data Message, Time Coordination Message)
   ** are sent directly within the SPDU (see [SIS_205]). Because the type of the HALC 
   ** command is known by the SPDU location, the identifier CSOS_k_CMD_IXSVO_IO_DATA 
   ** need not be set */
   
   /*******************************/
   /* For IO safety data consumer */
   /*******************************/
   /* if new Time Coordination Message available */
   /* Note 960: Violates MISRA 2004 Required Rule 12.4, side effects on right hand of logical 
    *  operator: '??' --> no side effects because because data must be set because of volatile 
    * access in spduIn_PrepIpcTcoo. */
   if ( (s_SafeTgmIpcTx.u8_tcooTgmCnt != RDS_GET(u8_LastSentTccoDui)) &&
        (s_SafeTgmIpcTx.u8_tcooTgmCnt == s_SafeTgmIpcRx.u8_tcooTgmCnt) ) /*lint !e960 */
   {
     /* set Time Coordination Message with elements from local and remote 
     ** controller instance */
     setTgmTcoo();
     /* update last sent DUI */
     RDS_SET(u8_LastSentTccoDui, s_SafeTgmIpcTx.u8_tcooTgmCnt);
   }
   /* no new Time Coordination Message */
   else
   {
     /* empty branch */
   }
   
   /*******************************/
   /* For IO safety data producer */
   /*******************************/
   /* if new IO Data Message available */
   /* Note 960: Violates MISRA 2004 Required Rule 12.4, side effects on right hand of logical 
    *  operator: '??' --> no side effects because because data must be set because of volatile 
    * access in spduIn_PrepIpcIo. */
   if ( (s_SafeTgmIpcTx.u8_dataTgmCnt != RDS_GET(u8_LastSentIoDui)) &&
        (s_SafeTgmIpcTx.u8_dataTgmCnt == s_SafeTgmIpcRx.u8_dataTgmCnt) ) /*lint !e960 */
   {   
     /* set IO Data Message with elements from local and remote 
     ** controller instance */
     setTgmIo();
     /* update last sent DUI */
     RDS_SET(u8_LastSentIoDui, s_SafeTgmIpcTx.u8_dataTgmCnt);
     
   }
   /* no new IO Data Message available */
   else
   {
     /* empty branch */
   }
}

/***************************************************************************************************
  Function:
    spduIn_BuildTgmDummy

  Description:
    Build an 'empty', not valid safe packet according to [SIS_CS].
    This function is used only when the SW is in a condition where a complete Telegram via AIC has
    to be send, but without "real" and valid safety communication (means no CIP Safety Connection 
    established).

  See also:
    -

  Parameters:
    -

  Return value:
    -

  Remarks:
    Context: IRQ Scheduler

***************************************************************************************************/
void spduIn_BuildTgmDummy (void)
{ 
  /* Connection is not open, set IO Data Message accordingly (see [SIS_212], [SIS_213]) */
  spduIn_s_Paket.u16_halcLen = AICMSGDEF_CIP_IN_DATA_SIZE;
  spduIn_s_Paket.u16_halcAddInfo = 0xFFFFu;
  stdlibHAL_ByteArrSet(spduIn_s_Paket.au8_data, 
                       (UINT8)0xFEu, 
                       (UINT16)AICMSGDEF_CIP_IN_DATA_SIZE);
  
  /* Connection is not open, set Time Coordination Message accordingly [SIS_212], [SIS_213] */
  spduIn_s_Paket.u16_halcAddInfo2 = 0xFFFFu;
  stdlibHAL_ByteArrSet(spduIn_s_Paket.au8_data2, 
                       (UINT8)0xFEu, 
                       (UINT16)AICMSGDEF_CIP_IN_DATA2_SIZE);
}

/***************************************************************************************************
  Function:
    spduIn_ResetTgmIo

  Description:
    This function is used to set the IO Data Message part of the T100 SPDU to default 
    values according to [SIS_CS]. This means
      - HALC length is set to AICMSGDEF_CIP_IN_DATA_SIZE (14 bytes)
      - HALC addInfo is set to 0xFFFF
      - data is filled with 0xFE

    This function is called whenever the Producing Connection is closed or faulted.

  See also:
    -

  Parameters:
    -

  Return value:
    -

  Remarks:
    Context: IRQ Scheduler

***************************************************************************************************/
void spduIn_ResetTgmIo (void)
{
   /* Producing Connection is not open, set IO Data Message  
   ** accordingly [SIS_212], [SIS_213] */
   /* Connection is not open, set IO Data Message accordingly (see [SIS_212], [SIS_213]) */
   spduIn_s_Paket.u16_halcLen = AICMSGDEF_CIP_IN_DATA_SIZE;
   spduIn_s_Paket.u16_halcAddInfo = 0xFFFFu;
   stdlibHAL_ByteArrSet(spduIn_s_Paket.au8_data, 
                        (UINT8)0xFEu, 
                        (UINT16)AICMSGDEF_CIP_IN_DATA_SIZE);
}

/***************************************************************************************************
  Function:
    spduIn_ResetTgmTcco

  Description:
    This function is used to set the Time Coordination Message part of the T100 SPDU to default 
    values according to [SIS_CS]. This means
      - HALC addInfo2 is set to 0xFFFF
      - data2 is filled with 0xFE

    This function is called whenever the Consuming Connection is closed or faulted.

  See also:
    -

  Parameters:
    -

  Return value:
    -

  Remarks:
    Context: IRQ Scheduler

***************************************************************************************************/
void spduIn_ResetTgmTcco (void)
{
  /* Consuming Connection is not open, set Time Coordination Message 
  ** accordingly [SIS_212], [SIS_213] */
  spduIn_s_Paket.u16_halcAddInfo2 = 0xFFFFu;
  stdlibHAL_ByteArrSet(spduIn_s_Paket.au8_data2, 
                       (UINT8)0xFEu, 
                       (UINT16)AICMSGDEF_CIP_IN_DATA2_SIZE);
}

/***************************************************************************************************
  Function:
    spduIn_SendSafeTgm

  Description:
    This function is used to send the subframes generated by the IXXAT CIP Safety Stack to the 
    other controller (via IPC) in order to build a complete frame (see [SRS_2150], [2.1-10:], 
    [2.1-5:]). Depending on the controller id either the even or the odd bytes are sent to the 
    other uc.

  See also:
    -

  Parameters:
    -

  Return value:
    -

  Remarks:
    Context: IRQ Scheduler

***************************************************************************************************/
void spduIn_SendSafeTgm(void)
{ 
  /* send data via IPC */
  /* Cast from pointer to pointer is intended here because the underlying function directly writes
  ** into the DMA buffer. */
  /* Note 960: Violates MISRA 2004 Required Rule 11.5, attempt to cast away const/volatile from a 
  ** pointer or reference. It is accepted to cast away volatile here because data must be set 
  ** because of volatile access in spduIn_PrepIpcIo and spduIn_PrepIpcTcoo */
  ipcxSYS_SendBuffer(IPCXSYS_IPC_ID_SAFETGM, 
                     (UINT8)sizeof(s_SafeTgmIpcTx), 
                     (UINT8*)&s_SafeTgmIpcTx); /*lint !e928, !e960 */
}

/***************************************************************************************************
  Function:
    spduIn_RecvSafeTgm

  Description:
    This function is used to receive the subframes generated by the IXXAT CIP Safety Stack from the 
    other controller (via IPC) in order to build a complete frame (see [SRS_2150], [2.1-10:], 
    [2.1-5:]).

  See also:
    -

  Parameters:
    -

  Return value:
    -

  Remarks:
    Context: IRQ Scheduler

***************************************************************************************************/
void spduIn_RecvSafeTgm(void)
{
  /* receive data via IPC */
  /* Cast from pointer to pointer is intended here because the underlying function directly reads
  ** from the DMA buffer. */
  ipcxSYS_GetBufferinclWait(IPCXSYS_IPC_ID_SAFETGM, 
                            (UINT8)sizeof(s_SafeTgmIpcRx), 
                            (UINT8*)&s_SafeTgmIpcRx); /*lint !e928 */
}

/***************************************************************************************************
  Function:
    spduIn_PrepIpcIo

  Description:
    This function is used to prepare the IPC structure (IO Data Message part) after a new IO Data 
    Message was generated by CSS. The structure is used to exchange the sub frames with the other 
    controller. The IPC transfer itself is triggered via spduIn_SendSafeTgm.

  See also:
    spduIn_SendSafeTgm

  Parameters:
    u32_addInfo (IN) - Additional info generated by CSS
                       (valid range: any, not checked)
    au8_ioData (IN)  - Subframe buffer (incomplete message) generated by CSS
                       (valid range: <>NULL, not checked, buffer provided by CSS)

  Return value:
    -

  Remarks:
    Context: Background Task

***************************************************************************************************/
void spduIn_PrepIpcIo (UINT32 u32_addInfo, const UINT8* au8_ioData)
{
  CFG_CONTROLLER_ID_ENUM             eControllerId;
  
  /* get the controller ID (see [SRS_345]) */
  eControllerId = cfgSYS_GetControllerID();
  
  /* increment Data Update Indicator */
  RDS_INC(u8_SubframeIoDui);
  
  /* if controller 1 */
  if (eControllerId == SAFETY_CONTROLLER_1)
  {
    /* Attention: IO Data Message buffer (s_SafeTgmIpcTx) and u32_IoDataAddInfoTx are accessed
    ** from background and IRQ scheduler task.
    ** The update is protected by disabling IRQs temporary
    */
    __disable_irq();
  
    /* copy remaining additional info for IO Data Message */
    u32_IoDataAddInfoTx = u32_addInfo;
    /* store data for IPC exchange */
    s_SafeTgmIpcTx.u8_dataTgmCnt  = RDS_GET(u8_SubframeIoDui);
    
    /*lint -esym(960, 17.4)*/
    /* Note 960: Violates MISRA 2004 Required Rule 17.4, pointer arithmetic
     * other than array indexing used
     * --> Deactivate Misra Rule 17.4, Array-Indexing is wanted. */
    /* extract even bytes */
    s_SafeTgmIpcTx.u8_dataTgm[0] = au8_ioData[0];
    s_SafeTgmIpcTx.u8_dataTgm[1] = au8_ioData[2];
    s_SafeTgmIpcTx.u8_dataTgm[2] = au8_ioData[4];
    s_SafeTgmIpcTx.u8_dataTgm[3] = au8_ioData[6];
    s_SafeTgmIpcTx.u8_dataTgm[4] = au8_ioData[8];
    s_SafeTgmIpcTx.u8_dataTgm[5] = au8_ioData[10];
    s_SafeTgmIpcTx.u8_dataTgm[6] = au8_ioData[12];
    /*lint +esym(960, 17.4)*/
    
    /* Attention: Enable IRQs again */
    __enable_irq();
  }
  /* else if controller 2 */
  else if (eControllerId == SAFETY_CONTROLLER_2)
  {
    /* Attention: IO Data Message buffer (s_SafeTgmIpcTx) and u32_IoDataAddInfoTx are accessed
    ** from background and IRQ scheduler task.
    ** The update is protected by disabling IRQs temporary
    */
    __disable_irq();
  
    /* copy remaining additional info for IO Data Message */
    u32_IoDataAddInfoTx = u32_addInfo;
    /* store data for IPC exchange */
    s_SafeTgmIpcTx.u8_dataTgmCnt  = RDS_GET(u8_SubframeIoDui);
    
    /*lint -esym(960, 17.4)*/
    /* Note 960: Violates MISRA 2004 Required Rule 17.4, pointer arithmetic
     * other than array indexing used
     * --> Deactivate Misra Rule 17.4, Array-Indexing is wanted. */
    /* extract odd bytes */
    s_SafeTgmIpcTx.u8_dataTgm[0] = au8_ioData[1];
    s_SafeTgmIpcTx.u8_dataTgm[1] = au8_ioData[3];
    s_SafeTgmIpcTx.u8_dataTgm[2] = au8_ioData[5];
    s_SafeTgmIpcTx.u8_dataTgm[3] = au8_ioData[7];
    s_SafeTgmIpcTx.u8_dataTgm[4] = au8_ioData[9];
    s_SafeTgmIpcTx.u8_dataTgm[5] = au8_ioData[11];
    s_SafeTgmIpcTx.u8_dataTgm[6] = au8_ioData[13];
    /*lint +esym(960, 17.4)*/
    
    /* Attention: Enable IRQs again */
    __enable_irq();
  }
  /* else: variable error */
  else
  {
    GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(1u));
  }
}

/***************************************************************************************************
  Function:
    spduIn_PrepIpcTcoo

  Description:
    This function is used to prepare the IPC structure (Time Coordination Message part) after a new
    Time Coordination Message was generated by CSS. The structure is used to exchange the sub frames
    with the other controller. The IPC transfer itself is triggered via spduIn_SendSafeTgm.

  See also:
    spduIn_SendSafeTgm

  Parameters:
    u32_addInfo (IN) - Additional info generated by CSS
                       (valid range: any, not checked)
    au8_tcoo (IN)    - Subframe buffer (incomplete message) generated by CSS
                       (valid range: <>NULL, not checked, buffer provided by CSS)

  Return value:
    -

  Remarks:
    Context: Background Task

***************************************************************************************************/
void spduIn_PrepIpcTcoo (UINT32 u32_addInfo, const UINT8* au8_tcoo)
{
  CFG_CONTROLLER_ID_ENUM             eControllerId;
  
  /* get the controller ID (see [SRS_345]) */
  eControllerId = cfgSYS_GetControllerID();
  
  /* increment Data Update Indicator */
  RDS_INC(u8_SubframeTcooDui);

  /* if controller 1 */
  if (eControllerId == SAFETY_CONTROLLER_1)
  {
    /* Attention: Time Coordination Message buffer (s_SafeTgmIpcTx) and u32_TcooAddInfoTx 
    ** are accessed from background and IRQ scheduler task.
    ** The update is protected by disabling IRQs temporary
    */
    __disable_irq();
  
    /* copy remaining additional info for Time Coordination Message */
    u32_TcooAddInfoTx =  u32_addInfo;
    /* store data for IPC exchange */
    s_SafeTgmIpcTx.u8_tcooTgmCnt  = RDS_GET(u8_SubframeTcooDui);
      
    /*lint -esym(960, 17.4)*/
    /* Note 960: Violates MISRA 2004 Required Rule 17.4, pointer arithmetic
     * other than array indexing used
     * --> Deactivate Misra Rule 17.4, Array-Indexing is wanted. */
    /* extract even bytes */
    s_SafeTgmIpcTx.u8_tcooTgm[0] = au8_tcoo[0];
    s_SafeTgmIpcTx.u8_tcooTgm[1] = au8_tcoo[2];
    s_SafeTgmIpcTx.u8_tcooTgm[2] = au8_tcoo[4];
    /*lint +esym(960, 17.4)*/
    
    /* Attention: Enable IRQs again */
    __enable_irq();
  }
  /* else if  controller 2 */
  else if (eControllerId == SAFETY_CONTROLLER_2)
  {
    /* Attention: Time Coordination Message buffer (s_SafeTgmIpcTx) and u32_TcooAddInfoTx 
    ** are accessed from background and IRQ scheduler task.
    ** The update is protected by disabling IRQs temporary
    */
    __disable_irq();
  
    /* copy remaining additional info for Time Coordination Message */
    u32_TcooAddInfoTx =  u32_addInfo;
    /* store data for IPC exchange */
    s_SafeTgmIpcTx.u8_tcooTgmCnt  = RDS_GET(u8_SubframeTcooDui);
    
    /*lint -esym(960, 17.4)*/
    /* Note 960: Violates MISRA 2004 Required Rule 17.4, pointer arithmetic
     * other than array indexing used
     * --> Deactivate Misra Rule 17.4, Array-Indexing is wanted. */
    /* extract odd bytes */
    s_SafeTgmIpcTx.u8_tcooTgm[0] = au8_tcoo[1];
    s_SafeTgmIpcTx.u8_tcooTgm[1] = au8_tcoo[3];
    s_SafeTgmIpcTx.u8_tcooTgm[2] = au8_tcoo[5];
    /*lint +esym(960, 17.4)*/
    
    /* Attention: Enable IRQs again */
    __enable_irq();
  }
  /* else: variable error */
  else
  {
    GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(2u));
  }
}

/***************************************************************************************************
**    static functions
***************************************************************************************************/

/***************************************************************************************************
  Function:
    setTgmTcoo

  Description:
    This function is used to set the Time Coordination Message part of the T100 SPDU according
    to the Message generated by the CIP Safety Target Stack (CSS).
    This function is called if a consuming connection is established and a new Time Coordination
    Message was generated.
    Depending on the controller id the even or odd bytes are taken from the local controller
    instance.
    The missing bytes are taken from the remote controller instance (see [2.1-10:]).

  See also:
    -

  Parameters:
    -

  Return value:
    -

  Remarks:
    Context: IRQ Scheduler

***************************************************************************************************/
STATIC void setTgmTcoo(void)
{
  CFG_CONTROLLER_ID_ENUM             eControllerId;
  
  /* get the controller ID (see [SRS_345]) */
  eControllerId = cfgSYS_GetControllerID();
  
  /* store Safety validator instance ID for time coordination message 
  ** (only 2 bytes because Safety validator instance ID is 2 bytes inside CSS)
  */
  spduIn_s_Paket.u16_halcAddInfo2 = (UINT16)u32_TcooAddInfoTx;
  
  /* if controller 1 */
  if (eControllerId == SAFETY_CONTROLLER_1)
  {
    /*lint -esym(960, 17.4)*/
    /* Note 960: Violates MISRA 2004 Required Rule 17.4, pointer arithmetic
    * other than array indexing used
    * --> Deactivate Misra Rule 17.4, Array-Indexing is wanted. */
    spduIn_s_Paket.au8_data2[0] = s_SafeTgmIpcTx.u8_tcooTgm[0];
    spduIn_s_Paket.au8_data2[1] = s_SafeTgmIpcRx.u8_tcooTgm[0];
    spduIn_s_Paket.au8_data2[2] = s_SafeTgmIpcTx.u8_tcooTgm[1];
    spduIn_s_Paket.au8_data2[3] = s_SafeTgmIpcRx.u8_tcooTgm[1];
    spduIn_s_Paket.au8_data2[4] = s_SafeTgmIpcTx.u8_tcooTgm[2];
    spduIn_s_Paket.au8_data2[5] = s_SafeTgmIpcRx.u8_tcooTgm[2];
    /*lint +esym(960, 17.4)*/
  }
  /* else if controller 2 */
  else if (eControllerId == SAFETY_CONTROLLER_2)
  {
    /*lint -esym(960, 17.4)*/
    /* Note 960: Violates MISRA 2004 Required Rule 17.4, pointer arithmetic
    * other than array indexing used
    * --> Deactivate Misra Rule 17.4, Array-Indexing is wanted. */
    spduIn_s_Paket.au8_data2[0] = s_SafeTgmIpcRx.u8_tcooTgm[0];
    spduIn_s_Paket.au8_data2[1] = s_SafeTgmIpcTx.u8_tcooTgm[0];
    spduIn_s_Paket.au8_data2[2] = s_SafeTgmIpcRx.u8_tcooTgm[1];
    spduIn_s_Paket.au8_data2[3] = s_SafeTgmIpcTx.u8_tcooTgm[1];
    spduIn_s_Paket.au8_data2[4] = s_SafeTgmIpcRx.u8_tcooTgm[2];
    spduIn_s_Paket.au8_data2[5] = s_SafeTgmIpcTx.u8_tcooTgm[2];
    /*lint +esym(960, 17.4)*/
  }
  /* else: variable error */
  else
  {
    GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(3u));
  }
  /* update DUI_data2 of telegram */
  spduIn_s_Paket.u8_duiData2 = s_SafeTgmIpcTx.u8_tcooTgmCnt;
}

/***************************************************************************************************
  Function:
    setTgmIo

  Description:
    This function is used to set the IO Data Message part of the T100 SPDU according
    to the Message generated by the CIP Safety Target Stack (CSS).
    This function is called if a producing connection is established and a new IO Data 
    Message was generated.
    Depending on the controller id the even or odd bytes are taken from the local controller
    instance.
    The missing bytes are taken from the remote controller instance (see [2.1-10:]).

  See also:
    -

  Parameters:
    -

  Return value:
    -

  Remarks:
    Context: IRQ Scheduler

***************************************************************************************************/
STATIC void setTgmIo(void)
{
  CFG_CONTROLLER_ID_ENUM             eControllerId;
  
  /* get the controller ID (see [SRS_345]) */
  eControllerId = cfgSYS_GetControllerID();
  
  /* store HALC length inside transmit buffer. Since a dedicated part inside the SPDU
  ** is used, the value is also fixed here. */
  spduIn_s_Paket.u16_halcLen = AICMSGDEF_CIP_IN_DATA_SIZE;
  /* store Safety validator instance ID for safety IO data 
  ** (only 2 bytes because Safety validator instance ID is 2 bytes inside CSS) */
  spduIn_s_Paket.u16_halcAddInfo = (UINT16)u32_IoDataAddInfoTx;
  
  /* if running on safety controller 1 */
  if (eControllerId == SAFETY_CONTROLLER_1)
  {
    /*lint -esym(960, 17.4)*/
    /* Note 960: Violates MISRA 2004 Required Rule 17.4, pointer arithmetic
    * other than array indexing used
    * --> Deactivate Misra Rule 17.4, Array-Indexing is wanted. */
    spduIn_s_Paket.au8_data[0]  = s_SafeTgmIpcTx.u8_dataTgm[0];
    spduIn_s_Paket.au8_data[1]  = s_SafeTgmIpcRx.u8_dataTgm[0];
    spduIn_s_Paket.au8_data[2]  = s_SafeTgmIpcTx.u8_dataTgm[1];
    spduIn_s_Paket.au8_data[3]  = s_SafeTgmIpcRx.u8_dataTgm[1];
    spduIn_s_Paket.au8_data[4]  = s_SafeTgmIpcTx.u8_dataTgm[2];
    spduIn_s_Paket.au8_data[5]  = s_SafeTgmIpcRx.u8_dataTgm[2];
    spduIn_s_Paket.au8_data[6]  = s_SafeTgmIpcTx.u8_dataTgm[3];
    spduIn_s_Paket.au8_data[7]  = s_SafeTgmIpcRx.u8_dataTgm[3];
    spduIn_s_Paket.au8_data[8]  = s_SafeTgmIpcTx.u8_dataTgm[4];
    spduIn_s_Paket.au8_data[9]  = s_SafeTgmIpcRx.u8_dataTgm[4];
    spduIn_s_Paket.au8_data[10] = s_SafeTgmIpcTx.u8_dataTgm[5];
    spduIn_s_Paket.au8_data[11] = s_SafeTgmIpcRx.u8_dataTgm[5];
    spduIn_s_Paket.au8_data[12] = s_SafeTgmIpcTx.u8_dataTgm[6];
    spduIn_s_Paket.au8_data[13] = s_SafeTgmIpcRx.u8_dataTgm[6];
    /*lint +esym(960, 17.4)*/
  }
  /* else if running on safety controller 2 */
  else if (eControllerId == SAFETY_CONTROLLER_2)
  {
     /*lint -esym(960, 17.4)*/
    /* Note 960: Violates MISRA 2004 Required Rule 17.4, pointer arithmetic
    * other than array indexing used
    * --> Deactivate Misra Rule 17.4, Array-Indexing is wanted. */
    spduIn_s_Paket.au8_data[0]  = s_SafeTgmIpcRx.u8_dataTgm[0];
    spduIn_s_Paket.au8_data[1]  = s_SafeTgmIpcTx.u8_dataTgm[0];
    spduIn_s_Paket.au8_data[2]  = s_SafeTgmIpcRx.u8_dataTgm[1];
    spduIn_s_Paket.au8_data[3]  = s_SafeTgmIpcTx.u8_dataTgm[1];
    spduIn_s_Paket.au8_data[4]  = s_SafeTgmIpcRx.u8_dataTgm[2];
    spduIn_s_Paket.au8_data[5]  = s_SafeTgmIpcTx.u8_dataTgm[2];
    spduIn_s_Paket.au8_data[6]  = s_SafeTgmIpcRx.u8_dataTgm[3];
    spduIn_s_Paket.au8_data[7]  = s_SafeTgmIpcTx.u8_dataTgm[3];
    spduIn_s_Paket.au8_data[8]  = s_SafeTgmIpcRx.u8_dataTgm[4];
    spduIn_s_Paket.au8_data[9]  = s_SafeTgmIpcTx.u8_dataTgm[4];
    spduIn_s_Paket.au8_data[10] = s_SafeTgmIpcRx.u8_dataTgm[5];
    spduIn_s_Paket.au8_data[11] = s_SafeTgmIpcTx.u8_dataTgm[5];
    spduIn_s_Paket.au8_data[12] = s_SafeTgmIpcRx.u8_dataTgm[6];
    spduIn_s_Paket.au8_data[13] = s_SafeTgmIpcTx.u8_dataTgm[6];
    /*lint +esym(960, 17.4)*/
  }
  /* else: variable error */
  else
  {
    GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(4u));
  }
  /* update DUI_data of telegram */
  spduIn_s_Paket.u8_duiData = s_SafeTgmIpcTx.u8_dataTgmCnt;
}
