/***************************************************************************************************
**    Copyright (C) 2016-2024 HMS Technology Center Ravensburg GmbH, all rights reserved
****************************************************************************************************
**
**        File: aicSm.c
**     Summary: This module implements the main state machine of the T100/CS. The module changes the
**              state according to global events set by IRQ scheduler or background task. The 
**              state is updated/checked once within T-cycl.
**   $Revision: 4440 $
**       $Date: 2024-05-29 14:03:45 +0200 (Mi, 29 Mai 2024) $
**      Author: K.Angele
** Responsible: (optional)
**
****************************************************************************************************
****************************************************************************************************
**
**  Functions: aicSm_SetEvent
**             aicSm_Statemachine
**             aicSm_CfgOwnerToolSet
**             aicSm_CfgOwnerOriginatorGetSet
**             aicSm_CfgIsOriginatorOwned
**
**             HandleEvent
**             StartupState
**             WaitForInitState
**             StartCssState
**             IdleState
**             ProducerOnlyState
**             ConsumerOnlyState
**             ProducerConsumerState
**             ProcessConfigState
**             WaitForConfigState
**             InvalidConfigState
**             WaitForTunidState
**             WaitResetState
**             AbortState
**
**    History:
**
****************************************************************************************************
**    Template Version 5
***************************************************************************************************/


/***************************************************************************************************
**    include-files
***************************************************************************************************/

/* system includes */
#include "xtypes.h"
#include "xdefs.h"
#include "rds.h"
#include "globFail_Errorcodes.h"
#include "globFail_SafetyHandler.h"
#include "globErrLog.h"

#include "includeDiDo.h"
#include "fiParam.h"

/* AIC module includes */
#include "aicMsgDef.h"

#include "aicIoRstDi.h"
#include "aicIoRstDo.h"
#include "aicSm.h"

#include "spduIn.h"
#include "spduOutData.h"

/***************************************************************************************************
**    global variables
***************************************************************************************************/

/* aicSm_eAicState:
** status of AIC, global used due to performance reasons
*/
volatile AICSM_STATE_ENUM aicSm_eAicState = AICSM_AIC_STARTUP;

/* aicSm_eFirstMsgReceived:
** This variable indicates if the first message is received correct.
*/
TRUE_FALSE_ENUM aicSm_eFirstMsgReceived = eFALSE;


/***************************************************************************************************
**    static constants, types, macros, variables
***************************************************************************************************/

/* Unique file id used to build additional info */
#define k_FILEID      12u

/* Max. number of events storeable
** Events can be generated by:
** (1.) CSS (during calling of cyclic API functions, e.g. Consumer Monitor Timeout)
** (2.) CSS (during processing of HALC Messages, e.g. Safety Open received)
** (3.) AIC Message processing (aicMsg) running in IRQ scheduler (e.g. SetInitData received)
** (4.) Application running in Background task (e.g. Configuration done)
** (5.) Ctrl/Status processing running in IRQ scheduler (e.g. Abort request from ABCC)
**
** The message queue size was calculated to process in each cycle (4ms) up to 4 events:
** - Two events of (1.) (one for each Safety Connection)
** - One event of (2.) respectively (3.) (only one message is received and processed in each cycle)
** - One event of (5.) (only one state request possible)
** Since (1.) events are only generated in 'Executing' state and (4.) event only in states 
** <>'Executing', no further queue entry is reserved here.
*/
#define cfg_MAX_NUM_EVENTS        (UINT8)4u

/* Event queue used to store events triggered by IRQ scheduler or Background Task */
STATIC volatile AICSM_t_EVENT ae_SmEvents[cfg_MAX_NUM_EVENTS] = { AICSM_k_EVT_NO_EVENT,
                                                                  AICSM_k_EVT_NO_EVENT,
                                                                  AICSM_k_EVT_NO_EVENT,
                                                                  AICSM_k_EVT_NO_EVENT };

/* aicSm_eCfgIsOriginatorOwned:
** This variable indicates if the device configuration is owned by an Originator (configuration was
** obtained via Type 1 SafetyOpen). Accessed from IRQ scheduler and Background Task.
*/
STATIC volatile TRUE_FALSE_ENUM aicSm_eCfgIsOriginatorOwned = eFALSE;
/* aicSm_eCfgIsToolOwned:
** This variable indicates if the device configuration is owned by a configuration tool
** (configuration was obtained from the host via AIC). Accessed from IRQ scheduler and Background
** Task.
*/
STATIC volatile TRUE_FALSE_ENUM aicSm_eCfgIsToolOwned = eFALSE;


/***************************************************************************************************
**    static function-prototypes
***************************************************************************************************/

STATIC void StartupState(void);
STATIC void WaitForInitState(AICSM_t_EVENT e_event);
STATIC void StartCssState(AICSM_t_EVENT e_event);
STATIC void IdleState(AICSM_t_EVENT e_event);
STATIC void ProcessConfigState(AICSM_t_EVENT e_event);
STATIC void WaitForConfigState(AICSM_t_EVENT e_event);
STATIC void InvalidConfigState(AICSM_t_EVENT e_event);
STATIC void WaitForTunidState(AICSM_t_EVENT e_event);
STATIC void ProducerOnlyState(AICSM_t_EVENT e_event);
STATIC void ConsumerOnlyState(AICSM_t_EVENT e_event);
STATIC void ProducerConsumerState(AICSM_t_EVENT e_event);
STATIC void WaitResetState(AICSM_t_EVENT e_event);
STATIC void AbortState(AICSM_t_EVENT e_event);
STATIC void HandleEvent(AICSM_t_EVENT e_event);

/***************************************************************************************************
**    global functions
***************************************************************************************************/

/***************************************************************************************************
  Function:
    aicSm_SetEvent

  Description:
    This functions is used to set a new event which shall be processed by the global state machine.
    The events are stored in a queue and processed during IRQ Scheduler. If the number of events 
    exceeds the limit 'cfg_MAX_NUM_EVENTS', a fail safe error is triggered.

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_e_EVENT, not checked here, checked if event is
                     processed via calling aicSm_Statemachine->HandleEvent)

  Return value:
    -

  Remarks:
    Context: IRQ Scheduler
    Context: Background Task

***************************************************************************************************/
void aicSm_SetEvent(AICSM_t_EVENT e_event)
{
  UINT8 i;
  BOOL b_evtSet = FALSE;
  
  /* the event queue is accessed from IRQ scheduler and Background Task. So it is necessary 
  ** to disable IRQs temporarily here. */
  __disable_irq();
  
  /* search event queue for a free entry, leave loop if event stored */
  for (i = 0u; ( (i < cfg_MAX_NUM_EVENTS) && (b_evtSet == FALSE) ); i++)
  {
    /* if entry of queue is free */
    if (ae_SmEvents[i] == AICSM_k_EVT_NO_EVENT)
    {
      ae_SmEvents[i] = e_event;
      b_evtSet = TRUE;
    }
    /* else: entry used, try next */
    else
    {
      /* empty branch */
    }
  }
  /* enable IRQs again */
  __enable_irq();
  
  /* if event not stored */
  if (b_evtSet == FALSE)
  {
    /* enter global fail safe state */
    GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_EVENT_CNT_ERR, GLOBFAIL_ADDINFO_FILE(1u));
  }
  /* else: event stored */
  else
  {
    /* empty branch */
  }
}

/***************************************************************************************************
  Function:
    aicSm_Statemachine

  Description:
    This function contains the statemachine for the AIC handling.

  See also:
    -

  Parameters:
    -

  Return value:
    -

  Remarks:
    Context: IRQ Scheduler

***************************************************************************************************/
void aicSm_Statemachine (void)
{
  UINT8 i;
  
  /* if in state 'AICSM_AIC_STARTUP', the proper state handler is called cyclically 
  ** because the existing interface global 'aicSm_eFirstMsgReceived' shall not be changed, 
  ** and this variable is set with every received frame */  
  if (aicSm_eAicState == AICSM_AIC_STARTUP)
  {
    StartupState();
  }
  /* else: in every other state, the event handler is only called, if an event was signalized by 
  ** IRQ scheduler or background task */
  else
  {
    /* Process ALL events generated since last call. If several events were generated,
    ** several state changes are possible here. */
    for (i = 0u; i < cfg_MAX_NUM_EVENTS; i++)
    {
      /* if event available */
      if (ae_SmEvents[i] != AICSM_k_EVT_NO_EVENT)
      {
        /* process event by the proper state handle */
        HandleEvent(ae_SmEvents[i]);
        /* mark event as consumed */
        ae_SmEvents[i] = AICSM_k_EVT_NO_EVENT;
      }
      /* else: no (further) event */
      else
      {
        /* empty branch */
      }
    }
  }
}

/***************************************************************************************************
  Function:
    aicSm_CfgOwnerToolSet

  Description:
    This function sets the configuration owner to the passed value.

  See also:
    -

  Parameters:
    b_isToolOwned (IN)  - TRUE:  Configuration owner is the configuration tool/host
                          FALSE: Configuration owner is Originator or there is not yet a
                                 configuration owner (un-owned)
                                 (valid range: any, not checked)

  Return value:
    -

  Remarks:
    Context: IRQ Scheduler (only in AIC state AICSM_AIC_IDLE, AICSM_AIC_WAIT_FOR_CONFIG
                            or AICSM_AIC_INVALID_CONFIG)
    Context: Background Task (only in AIC state AICSM_AIC_START_CSS)
    => concurrent access to this function is not possible (ruled out by AIC state machine)

***************************************************************************************************/
void aicSm_CfgOwnerToolSet(BOOL b_isToolOwned)
{
  /* if caller wants to set 'Originator owned' */
  if (b_isToolOwned == TRUE)
  {
    /* store in global variable - with hamming distance */
    aicSm_eCfgIsToolOwned = eTRUE;
  }
  else  /* else: caller wants to set 'tool/host owned' or un-owned */
  {
    /* store in global variable - with hamming distance */
    aicSm_eCfgIsToolOwned = eFALSE;
  }
}

/***************************************************************************************************
  Function:
    aicSm_CfgOwnerOriginatorGetSet

  Description:
    This function sets the configuration owner to the passed value if possible. It is only possible
    to set the configuration owner if the device is not configured by a configuration tool/host.

  See also:
    -

  Parameters:
    b_isOriginatorOwned (IN)  - TRUE:  Configuration owner is an Originator
                                FALSE: Configuration owner is a configuration tool/host or there is
                                       not yet a configuration owner (un-owned)
                                (valid range: any, not checked)

  Return value:
    TRUE  - it was possible to set the configuration owner to the passed value
    FALSE - it was not possible to set the configuration owner to the passed value

  Remarks:
    Context: Background Task

***************************************************************************************************/
BOOL aicSm_CfgOwnerOriginatorGetSet(BOOL b_isOriginatorOwned)
{
  BOOL b_retVal = FALSE;

  /* The b_isOriginatorOwned and aicSm_eCfgIsToolOwned flags are accessed from IRQ scheduler and
  ** Background Task. So it is necessary to disable IRQs temporarily here. */
  __disable_irq();

  /* if global variable says it is Tool-owned */
  if (aicSm_eCfgIsToolOwned == eTRUE)
  {
    /* not possible to change ownership */
    /* return value already set */
    /* additionally make sure that when the configuration is tool-owned then it cannot be owned by
       an Originator */
    /* store in global variable - with hamming distance */
    aicSm_eCfgIsOriginatorOwned = eFALSE;
  }
  else if (aicSm_eCfgIsToolOwned == eFALSE)
  {
    /* if caller wants to set 'Originator owned' */
    if (b_isOriginatorOwned == TRUE)
    {
      /* store in global variable - with hamming distance */
      aicSm_eCfgIsOriginatorOwned = eTRUE;
    }
    else  /* else: caller wants to set 'tool/host owned' or un-owned */
    {
      /* store in global variable - with hamming distance */
      aicSm_eCfgIsOriginatorOwned = eFALSE;
    }
    b_retVal = TRUE;
  }
  else
  {
    GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(40u));
    /* return value already set */
  }

  /* enable IRQs again */
  __enable_irq();

  return b_retVal;
}

/***************************************************************************************************
  Function:
    aicSm_CfgIsOriginatorOwned

  Description:
    This function checks if the device's configuration owner is an Originator (that has sent the
    configuration via Type 1 SafetyOpen). If not then the device is either configured by a
    configuration tool (means the device was configured from the host via AIC) or is not configured
    yet (un-owned).

  See also:
    -

  Parameters:
    -

  Return value:
    TRUE  - Configuration owner is an Originator
    FALSE - Configuration owner is a configuration tool/host or the there is not yet a configuration
            owner (un-owned)

  Remarks:
    Context: IRQ Scheduler

***************************************************************************************************/
BOOL aicSm_CfgIsOriginatorOwned(void)
{
  BOOL b_retVal = FALSE;

  /* if global variable says it is Originator owned */
  if (aicSm_eCfgIsOriginatorOwned == eTRUE)
  {
    b_retVal = TRUE;
  }
  else if (aicSm_eCfgIsOriginatorOwned == eFALSE)  /* else: if it is not Originator owned */
  {
    /* return value already set */
    /* empty branch */
  }
  else  /*else: if unexpected value */
  {
    GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(41u));
    /* return value already set */
  }

  return b_retVal;
}


/***************************************************************************************************
**    static functions
***************************************************************************************************/

/***************************************************************************************************
  Function:
    HandleEvent

  Description:
    This functions is used to handle an event triggered by IRQ scheduler or Background Task.
    Depending on the current state, the proper state handler is called. 

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_e_EVENT, not checked, checked by state handler)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void HandleEvent(AICSM_t_EVENT e_event)
{
  /* check current AIC state and call the proper state handler  */ 
  switch(aicSm_eAicState)
  {
     case AICSM_AIC_WAIT_FOR_INIT:
     {
        /* call function to handle wait for init state */
        WaitForInitState(e_event);
        break;
     }
     
     case AICSM_AIC_START_CSS:
     {
        /* call function to handle start CSS state */
        StartCssState(e_event);
        break;
     }
     
     case AICSM_AIC_WAIT_TUNID:
     {
       /* call function to handle wait for TUNID state */
       WaitForTunidState(e_event);
       break;
     }
     
     case AICSM_AIC_WAIT_FOR_CONFIG:
     {
       /* call function to handle wait for config state */
       WaitForConfigState(e_event);
       break;
     }
     
     case AICSM_AIC_PROCESS_CONFIG:
     {
       /* call function to handle process config state */
       ProcessConfigState(e_event);
       break;
     }
     
     case AICSM_AIC_INVALID_CONFIG:
     {
       /* call function to handle invalid config state */
       InvalidConfigState(e_event);
       break;
     }
     
     case AICSM_AIC_IDLE:
     {
        /* call function to handle idle state */
        IdleState(e_event);
        break;
     }
     
     case AICSM_AIC_EXEC_PROD_ONLY:
     {
        /* call function to handle producing only state */
        ProducerOnlyState(e_event);
        break;
     }
        
     case AICSM_AIC_EXEC_CONS_ONLY:
     {
        /* call function to handle consuming only state */
        ConsumerOnlyState(e_event);
        break;
     }
        
     case AICSM_AIC_EXEC_PROD_CONS:
     {
        /* call function to handle consuming and producing state */
        ProducerConsumerState(e_event);
        break;
     }
     
     case AICSM_AIC_WAIT_RESET:
     {
       /* call function to handle wait reset state */
       WaitResetState(e_event);
       break;
     }
     
     case AICSM_AIC_ABORT:
     {
       /* call function to handle abort state */
       AbortState(e_event);
       break;
     }
     
     /* State AICSM_AIC_STARTUP is already handled directly in aicSm_Statemachine().
     ** So this case should never be reached here.
     */
     case AICSM_AIC_STARTUP:
     {
       /* invalid state  */
       GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(2u));
       break;
     } /* CCT_SKIP */ /* can not be reached, already handled in aicSm_Statemachine() */

     default:
     {
        /* invalid value of variable */
        GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(3u));
        break;
     }
  }
}

/***************************************************************************************************
  Function:
    StartupState

  Description:
    This function handles the AIC-State "startup" and switches to next state if AM-Telegram 
    (response from other module) was received via AIC

  See also:
    -

  Parameters:
    -

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void StartupState(void)
{
   /* if an answer was received, switch to next state (see [SRS_428]),
    * else stay here forever... */
   if (eTRUE == aicSm_eFirstMsgReceived)
   {
      /* enter next state.
      ** This signalizes, that CSS initialization parameters shall be received from AM now
      ** (see [SRS_2216])
      */     
      aicSm_eAicState = AICSM_AIC_WAIT_FOR_INIT;
   }
   /* else: no answer from ASM received yet */
   else
   {
     /* empty branch */
   }
}


/***************************************************************************************************
  Function:
    WaitForInitState

  Description:
    This function handles the AIC-State "wait for init" and switches to next state if the 
    initialization data was received via AIC

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_t_EVENT, checked)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void WaitForInitState(AICSM_t_EVENT e_event)
{
  /* evaluate event */
  switch (e_event)
  {
    case AICSM_k_EVT_CSS_INIT_RECEIVED:
    {
      aicSm_eAicState = AICSM_AIC_START_CSS;
      break;
    }
    /* invalid/unexpected events are ignored */
    case AICSM_k_EVT_CSS_INIT_WAIT_TUNID:    /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_CONFIG:   /* fall through */
    case AICSM_k_EVT_CSS_INIT_IDLE:          /* fall through */
    case AICSM_k_EVT_CSS_INIT_INVLD_NODEID:  /* fall through */
    case AICSM_k_EVT_TUNID_RECEIVED:         /* fall through */
    case AICSM_k_EVT_CONFIG_RECEIVED:        /* fall through */
    case AICSM_k_EVT_INVLD_CONFIG:           /* fall through */
    case AICSM_k_EVT_CONFIG_DONE:            /* fall through */
    case AICSM_k_EVT_PROD_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_PROD_CONN_CLOSED:       /* fall through */
    case AICSM_k_EVT_PROD_CONN_FAULTED:      /* fall through */
    case AICSM_k_EVT_CONS_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_CONS_CONN_CLOSED:       /* fall through */
    case AICSM_k_EVT_CONS_CONN_FAULTED:      /* fall through */
    case AICSM_k_EVT_SAFETY_RESET:           /* fall through */
    case AICSM_k_EVT_ABORT_REQUEST:          /* fall through */
    {
      /* invalid/unexpected state transition, store inside Error Event log,
      ** (see [SRS_2163]) */
      globErrLog_ErrorAdd(GLOBERRLOG_FILE(4u));
      break;
    }
    /* state handler is only called if event != AICSM_k_EVT_NO_EVENT, so this case
    ** should never be reached here.
    */
    case AICSM_k_EVT_NO_EVENT:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(5u));
      break;
    } /* CCT_SKIP */ /* function not called if event == AICSM_k_EVT_NO_EVENT */
    default:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(6u));
      break;
    }
  }
/* This function has a lot of paths because all possible events are catched inside the 
** switch/case. But de facto the function is not really complex. */
/* RSM_IGNORE_QUALITY_BEGIN Notice #28   - Cyclomatic complexity > 15 */
}
/* RSM_IGNORE_QUALITY_END */


/***************************************************************************************************
  Function:
    StartCssState

  Description:
    This function handles the AIC-State "start CSS" and switches to next state if the CSS was
    initialized.

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_t_EVENT, checked)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void StartCssState(AICSM_t_EVENT e_event)
{
  /* evaluate event */
  switch (e_event)
  {
    /* CSS is initialized, a valid TUNID is stored and a valid configuration is
    ** stored inside NV memory (see [SRS_2004]) */
    case AICSM_k_EVT_CSS_INIT_IDLE:
    {
      /* activate cyclic check */
      fiParam_setSafConCheckActive (eTRUE);
      
      /* call state initialization of DI and DO module, this is done after
       * receiving parameters because a part of DI/DO initialization depends
       * on iParameters (see [SRS_2155]). Here the internal DI/DO state machines are set to their
       * default (safety) state (see [SRS_2080]). */
      gpio_InitModules();
      
      /* re-init automatic reset module to take over the configuration */
      aicIoRstDi_Init();
      aicIoRstDo_Init();
      
      /* enter next AIC state (see [SRS_2004]) */
      aicSm_eAicState = AICSM_AIC_IDLE;
      break;
    }
    /* CSS is initialized, no valid TUNID is stored inside NV memory (see [SRS_2195]) */
    case AICSM_k_EVT_CSS_INIT_WAIT_TUNID:
    {
      /* enter to next state (see [SRS_2195]) */
      aicSm_eAicState = AICSM_AIC_WAIT_TUNID;
      break;
    }
    /* CSS is initialized, a valid TUNID is stored but no configuration is
    ** set (see [SRS_2196]) */
    case AICSM_k_EVT_CSS_INIT_WAIT_CONFIG:
    {
      /* enter next AIC state (see [SRS_2196]) */
      aicSm_eAicState = AICSM_AIC_WAIT_FOR_CONFIG;
      break;
    }
    /* CSS is initialized, the received NodeID does not match to the stored 
    ** TUNID (see [SRS_2207]) */
    case AICSM_k_EVT_CSS_INIT_INVLD_NODEID:
    {
      /* enter next AIC state (see [SRS_2207]) */
      aicSm_eAicState = AICSM_AIC_ABORT;
      break;
    }
    /* invalid/unexpected events are ignored */
    case AICSM_k_EVT_CSS_INIT_RECEIVED:       /* fall through */
    case AICSM_k_EVT_TUNID_RECEIVED:          /* fall through */
    case AICSM_k_EVT_CONFIG_RECEIVED:         /* fall through */
    case AICSM_k_EVT_INVLD_CONFIG:            /* fall through */
    case AICSM_k_EVT_CONFIG_DONE:             /* fall through */
    case AICSM_k_EVT_PROD_CONN_ESTABLISHED:   /* fall through */
    case AICSM_k_EVT_PROD_CONN_CLOSED:        /* fall through */
    case AICSM_k_EVT_PROD_CONN_FAULTED:       /* fall through */
    case AICSM_k_EVT_CONS_CONN_ESTABLISHED:   /* fall through */
    case AICSM_k_EVT_CONS_CONN_CLOSED:        /* fall through */
    case AICSM_k_EVT_CONS_CONN_FAULTED:       /* fall through */
    case AICSM_k_EVT_SAFETY_RESET:            /* fall through */
    case AICSM_k_EVT_ABORT_REQUEST:           /* fall through */
    {
      /* invalid/unexpected state transition, store inside Error Event log,
      ** (see [SRS_2163]) */
      globErrLog_ErrorAdd(GLOBERRLOG_FILE(7u));
      break;
    }
    /* state handler is only called if event != AICSM_k_EVT_NO_EVENT, so this case
    ** should never be reached here.
    */
    case AICSM_k_EVT_NO_EVENT:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(8u));
      break;
    } /* CCT_SKIP */ /* function not called if event == AICSM_k_EVT_NO_EVENT */
    default:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(9u));
      break;
    }
  }
/* This function has a lot of paths because all possible events are catched inside the 
** switch/case. But de facto the function is not really complex. */
/* RSM_IGNORE_QUALITY_BEGIN Notice #28   - Cyclomatic complexity > 15 */
}
/* RSM_IGNORE_QUALITY_END */


/***************************************************************************************************
  Function:
    IdleState

  Description:
    This function handles the AIC-State "Idle" and switches to 'Executing' next state if at least 
    one IO connection was established.

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_t_EVENT, checked)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void IdleState(AICSM_t_EVENT e_event)
{
  /* evaluate event */
  switch (e_event)
  {
    /* Producer Connection established (see [SRS_2006]) */
    case AICSM_k_EVT_PROD_CONN_ESTABLISHED:
    {
      /* switch to executing state (producer only) state (see [SRS_2006]) */
      aicSm_eAicState = AICSM_AIC_EXEC_PROD_ONLY; 
      break;
    }
    /* Consumer Connection established (see [SRS_2006]) */
    case AICSM_k_EVT_CONS_CONN_ESTABLISHED:
    {
      /* switch to executing state (consumer only) state (see [SRS_2006]) */
      aicSm_eAicState = AICSM_AIC_EXEC_CONS_ONLY; 
      break;
    }
    /* 'Configure Request' was received, switch to 'Config' state for 
    ** re-configuration (see [SRS_2203]) */
    case AICSM_k_EVT_CONFIG_RECEIVED:
    {
      /* deactivate cyclic check */
      fiParam_setSafConCheckActive (eFALSE);
      /* switch to next state (see [SRS_2203]) */
      aicSm_eAicState = AICSM_AIC_PROCESS_CONFIG;
      break;
    }
    /* 'Safety Reset' received (see [SRS_2204]) */
    case AICSM_k_EVT_SAFETY_RESET:
    {
      /* switch to WAIT_RESET state (see [SRS_2204]) */
      aicSm_eAicState = AICSM_AIC_WAIT_RESET;
      break;
    }
    
    /* Since it is possible that a ForwardClose Request is received after 
    ** the T100/CS is already in Idle state (e.g. faulted connection), 
    ** a ForwardClose Request is ignored here. */
    case AICSM_k_EVT_PROD_CONN_CLOSED: 
    case AICSM_k_EVT_CONS_CONN_CLOSED:       /* fall through */
    {
      /* stay in state */
      break;
    }

    /* Abort Request received from ABCC (see [SRS_2245]) */
    case AICSM_k_EVT_ABORT_REQUEST:
    {
      /* switch to ABORT state (see [SRS_2245]) */
      aicSm_eAicState = AICSM_AIC_ABORT;
      break;
    }
      
    /* invalid/unexpected events are ignored */
    case AICSM_k_EVT_CSS_INIT_RECEIVED:      /* fall through */      
    case AICSM_k_EVT_CSS_INIT_WAIT_TUNID :   /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_CONFIG:   /* fall through */
    case AICSM_k_EVT_CSS_INIT_IDLE:          /* fall through */
    case AICSM_k_EVT_CSS_INIT_INVLD_NODEID:  /* fall through */
    case AICSM_k_EVT_TUNID_RECEIVED:         /* fall through */
    case AICSM_k_EVT_INVLD_CONFIG:           /* fall through */
    case AICSM_k_EVT_CONFIG_DONE:            /* fall through */
    case AICSM_k_EVT_PROD_CONN_FAULTED:      /* fall through */
    case AICSM_k_EVT_CONS_CONN_FAULTED:      /* fall through */
    {
      /* invalid/unexpected state transition, store inside Error Event log,
      ** (see [SRS_2163]) */
      globErrLog_ErrorAdd(GLOBERRLOG_FILE(10u));
      break;
    }
    /* state handler is only called if event != AICSM_k_EVT_NO_EVENT, so this case
    ** should never be reached here.
    */
    case AICSM_k_EVT_NO_EVENT:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(11u));
      break;
    } /* CCT_SKIP */ /* function not called if event == AICSM_k_EVT_NO_EVENT */
    default:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(12u));
      break;
    }
  }
/* This function has a lot of paths because all possible events are catched inside the 
** switch/case. But de facto the function is not really complex. */
/* RSM_IGNORE_QUALITY_BEGIN Notice #28   - Cyclomatic complexity > 15 */
}
/* RSM_IGNORE_QUALITY_END */

/***************************************************************************************************
  Function:
    ProducerOnlyState

  Description:
    This function handles the AIC-State "executing" and switches back if no IO connection is 
    established any more.

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_t_EVENT, checked)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void ProducerOnlyState(AICSM_t_EVENT e_event)
{
  /* evaluate event */
  switch (e_event)
  {
    /* if Producing Connection is not available any more this means that all 
    ** Safety Connections are closed/faulted (see [SRS_2136]) */
    case AICSM_k_EVT_PROD_CONN_CLOSED:
    case AICSM_k_EVT_PROD_CONN_FAULTED:      /* fall through */
    {
      /* reset data of IO Data Message in Input Packet */
      spduIn_ResetTgmIo();
      
      /* switch back to idle state (see [SRS_2136])*/
      aicSm_eAicState = AICSM_AIC_IDLE; 
      break;
    }
    /* else if Consumer Connection is also established now */
    case AICSM_k_EVT_CONS_CONN_ESTABLISHED:
    {
      /* switch to consumer and producer executing state */
      aicSm_eAicState = AICSM_AIC_EXEC_PROD_CONS; 
      break;
    }
    
    /* Since it is possible that a ForwardClose Request for the Consuming Connection
    ** is received after the T100/CS is already in 'ProducerOnly' state 
    ** (e.g. faulted connection), a ForwardClose Request for the Consuming Connection 
    ** is ignored here. */
    case AICSM_k_EVT_CONS_CONN_CLOSED:
    {
      /* stay in state */
      break;
    }
    
    /* Abort Request received from ABCC (see [SRS_2246]) */
    case AICSM_k_EVT_ABORT_REQUEST:
    {
      /* reset data of IO Data Message in Input Packet */
      spduIn_ResetTgmIo();

      /* switch to ABORT state (see [SRS_2246]) */
      aicSm_eAicState = AICSM_AIC_ABORT;
      break;
    }

    /* invalid/unexpected events are ignored */
    case AICSM_k_EVT_SAFETY_RESET:           /* fall through */
    case AICSM_k_EVT_CSS_INIT_RECEIVED:      /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_TUNID:    /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_CONFIG:   /* fall through */
    case AICSM_k_EVT_CSS_INIT_IDLE:          /* fall through */
    case AICSM_k_EVT_CSS_INIT_INVLD_NODEID:  /* fall through */
    case AICSM_k_EVT_TUNID_RECEIVED:         /* fall through */
    case AICSM_k_EVT_CONFIG_RECEIVED:        /* fall through */
    case AICSM_k_EVT_INVLD_CONFIG:           /* fall through */
    case AICSM_k_EVT_CONFIG_DONE:            /* fall through */
    case AICSM_k_EVT_PROD_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_CONS_CONN_FAULTED:      /* fall through */
    {
      /* invalid/unexpected state transition, store inside Error Event log,
      ** (see [SRS_2163]) */
      globErrLog_ErrorAdd(GLOBERRLOG_FILE(13u));
      break;
    }
    /* state handler is only called if event != AICSM_k_EVT_NO_EVENT, so this case
    ** should never be reached here.
    */
    case AICSM_k_EVT_NO_EVENT:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(14u));
      break;
    } /* CCT_SKIP */ /* function not called if event == AICSM_k_EVT_NO_EVENT */
    default:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(15u));
      break;
    }
  }
/* This function has a lot of paths because all possible events are catched inside the 
** switch/case. But de facto the function is not really complex. */
/* RSM_IGNORE_QUALITY_BEGIN Notice #28   - Cyclomatic complexity > 15 */
}
/* RSM_IGNORE_QUALITY_END */

/***************************************************************************************************
  Function:
    ConsumerOnlyState

  Description:
    This function handles the AIC-State "executing" and switches back if no IO connection is 
    established any more.

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_t_EVENT, checked)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void ConsumerOnlyState(AICSM_t_EVENT e_event)
{
  /* evaluate event */
  switch (e_event)
  {
    /* if Consumer Connection is not available any more this means that all 
    ** Safety Connections are closed/faulted (see [SRS_2136]) */
    case AICSM_k_EVT_CONS_CONN_CLOSED:
    case AICSM_k_EVT_CONS_CONN_FAULTED:      /* fall through */
    {
      /* reset values of IO output */
      spduOutData_Reset();
      
      /* reset data of Time Coordination Message in input packet */
      spduIn_ResetTgmTcco();
      
      /* switch back IDLE state (see [SRS_2136]) */
      aicSm_eAicState = AICSM_AIC_IDLE; 
      break;
    }
    /* else if Producer Connection is also established now */
    case AICSM_k_EVT_PROD_CONN_ESTABLISHED:
    {
      /* switch to consumer and producer executing state */
      aicSm_eAicState = AICSM_AIC_EXEC_PROD_CONS;
      break;
    }
    
    /* Since it is possible that a ForwardClose Request for the Producing Connection
    ** is received after the T100/CS is already in 'ConsumerOnly' state 
    ** (e.g. faulted connection), a ForwardClose Request for the Producing Connection 
    ** is ignored here. */
    case AICSM_k_EVT_PROD_CONN_CLOSED:
    {
      /* stay in state */
      break;
    }
    
    /* Abort Request received from ABCC (see [SRS_2246]) */
    case AICSM_k_EVT_ABORT_REQUEST:
    {
      /* reset values of IO output */
      spduOutData_Reset();

      /* reset data of Time Coordination Message in input packet */
      spduIn_ResetTgmTcco();

      /* switch to ABORT state (see [SRS_2246]) */
      aicSm_eAicState = AICSM_AIC_ABORT;
      break;
    }

    /* invalid/unexpected events are ignored */
    case AICSM_k_EVT_SAFETY_RESET:           /* fall through */
    case AICSM_k_EVT_CSS_INIT_RECEIVED:      /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_TUNID:    /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_CONFIG:   /* fall through */
    case AICSM_k_EVT_CSS_INIT_IDLE:          /* fall through */
    case AICSM_k_EVT_CSS_INIT_INVLD_NODEID:  /* fall through */
    case AICSM_k_EVT_TUNID_RECEIVED:         /* fall through */
    case AICSM_k_EVT_CONFIG_RECEIVED:        /* fall through */
    case AICSM_k_EVT_INVLD_CONFIG:           /* fall through */
    case AICSM_k_EVT_CONFIG_DONE:            /* fall through */
    case AICSM_k_EVT_CONS_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_PROD_CONN_FAULTED:      /* fall through */
    {
      /* invalid/unexpected state transition, store inside Error Event log,
      ** (see [SRS_2163]) */
      globErrLog_ErrorAdd(GLOBERRLOG_FILE(16u));
      break;
    }
    /* state handler is only called if event != AICSM_k_EVT_NO_EVENT, so this case
    ** should never be reached here.
    */
    case AICSM_k_EVT_NO_EVENT:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(17u));
      break;
    } /* CCT_SKIP */ /* function not called if event == AICSM_k_EVT_NO_EVENT */
    default:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(18u));
      break;
    }
  }
/* This function has a lot of paths because all possible events are catched inside the 
** switch/case. But de facto the function is not really complex. */
/* RSM_IGNORE_QUALITY_BEGIN Notice #28   - Cyclomatic complexity > 15 */
}
/* RSM_IGNORE_QUALITY_END */

/***************************************************************************************************
  Function:
    ProducerConsumerState

  Description:
    This function handles the AIC-State "executing" and switches back if no IO connection is 
    established any more.

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_t_EVENT, checked)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void ProducerConsumerState(AICSM_t_EVENT e_event)
{
  /* evaluate event */
  switch (e_event)
  {
    /* if Producer Connection is not any more available (closed/faulted) this means that 
    ** still the Consuming Connection is available */
    case AICSM_k_EVT_PROD_CONN_CLOSED:
    case AICSM_k_EVT_PROD_CONN_FAULTED:      /* fall through */
    {
      /* reset data of IO Data Message in Input Packet */
      spduIn_ResetTgmIo();
      /* switch to consumer only state */
      aicSm_eAicState = AICSM_AIC_EXEC_CONS_ONLY; 
      break;
    }
    /* if Consumer Connection is not any more available (closed/faulted) this means that 
    ** still the Producing Connection is available */
    case AICSM_k_EVT_CONS_CONN_CLOSED:
    case AICSM_k_EVT_CONS_CONN_FAULTED:      /* fall through */
    {
      /* reset values of IO output */
      spduOutData_Reset();
      
      /* reset data of Time Coordination Message in input packet */
      spduIn_ResetTgmTcco();
      
      /* switch to producer only state */
      aicSm_eAicState = AICSM_AIC_EXEC_PROD_ONLY; 
      break;
    }

    /* Abort Request received from ABCC (see [SRS_2246]) */
    case AICSM_k_EVT_ABORT_REQUEST:
    {
      /* reset data of IO Data Message in Input Packet */
      spduIn_ResetTgmIo();

      /* reset values of IO output */
      spduOutData_Reset();

      /* reset data of Time Coordination Message in Input packet */
      spduIn_ResetTgmTcco();

      /* switch to ABORT state (see [SRS_2246]) */
      aicSm_eAicState = AICSM_AIC_ABORT;
      break;
    }

    /* invalid/unexpected events are ignored */
    case AICSM_k_EVT_SAFETY_RESET:           /* fall through */
    case AICSM_k_EVT_CSS_INIT_RECEIVED:      /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_TUNID:    /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_CONFIG:   /* fall through */
    case AICSM_k_EVT_CSS_INIT_IDLE:          /* fall through */
    case AICSM_k_EVT_CSS_INIT_INVLD_NODEID:  /* fall through */
    case AICSM_k_EVT_TUNID_RECEIVED:         /* fall through */
    case AICSM_k_EVT_CONFIG_RECEIVED:        /* fall through */
    case AICSM_k_EVT_INVLD_CONFIG:           /* fall through */
    case AICSM_k_EVT_CONFIG_DONE:            /* fall through */
    case AICSM_k_EVT_PROD_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_CONS_CONN_ESTABLISHED:  /* fall through */
    {
      /* invalid/unexpected state transition, store inside Error Event log,
      ** (see [SRS_2163]) */
      globErrLog_ErrorAdd(GLOBERRLOG_FILE(19u));
      break;
    }
    /* state handler is only called if event != AICSM_k_EVT_NO_EVENT, so this case
    ** should never be reached here.
    */
    case AICSM_k_EVT_NO_EVENT:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(20u));
      break;
    } /* CCT_SKIP */ /* function not called if event == AICSM_k_EVT_NO_EVENT */
    default:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(21u));
      break;
    }
  }
/* This function has a lot of paths because all possible events are catched inside the 
** switch/case. But de facto the function is not really complex. */
/* RSM_IGNORE_QUALITY_BEGIN Notice #28   - Cyclomatic complexity > 15 */
}
/* RSM_IGNORE_QUALITY_END */

/***************************************************************************************************
  Function:
    ProcessConfigState

  Description:
    This function handles the AIC-State "Process Config".

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_t_EVENT, checked)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void ProcessConfigState(AICSM_t_EVENT e_event)
{
  /* evaluate event */
  switch (e_event)
  {
    /* if IO Device is configured now */
    case AICSM_k_EVT_CONFIG_DONE:
    {
      UINT32 u32_sccrc;
      UINT8 *pu8_cfgData = fiParam_getCandidateIParam(&u32_sccrc);

      /* if a candidate IParam set is temporarily saved */
      if (u32_sccrc != 0u)
      {
        /* if the temporary IParam set is consistent */
        if (fiParam_checkCandidateIParam() == TRUE)
        {
          /* set IO Configuration Data + SCCRC inside pkgParam */
          fiParam_setIParam(pu8_cfgData, (UINT8)(sizeof(PARAMETER_IPAR_STRUCT)));
          fiParam_setIParCrc(u32_sccrc);
          /* temporarily stored IParams are not needed any more */
          fiParam_clearCandidateIParam();
        }
        else  /* else: IParam set is corrupt */
        {
          GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(42u));
        }
      }
      else  /* else: no candidate IParam available */
      {
        /* IParameters and CRC already set */
      }

      /* activate cyclic check */
      fiParam_setSafConCheckActive(eTRUE);
      /* call state initialization of DI and DO module, this is done after
       * receiving parameters because a part of DI/DO initialization depends
       * on iParameters (see [SRS_2155]). Here the internal DI/DO state machines are set to their
       * default (safety) state (see [SRS_2080]). */
      gpio_InitModules();
      
      /* re-init automatic reset module to take over the configuration */
      aicIoRstDi_Init();
      aicIoRstDo_Init();
      
      /* switch to IDLE state (see [SRS_2202]) */
      aicSm_eAicState = AICSM_AIC_IDLE;
      break;
    }
    /* If invalid IO Configuration data received (invalid SCCRC) */
    case AICSM_k_EVT_INVLD_CONFIG:
    {
      /* switch state */
      aicSm_eAicState = AICSM_AIC_INVALID_CONFIG; 
      break;
    }
    /* Safety Reset received (see [SRS_2210]) */
    case AICSM_k_EVT_SAFETY_RESET:
    {
      /* switch to WAIT_RESET state (see [SRS_2210]) */
      aicSm_eAicState = AICSM_AIC_WAIT_RESET;
      break;
    }
    
    /* In case of a faulted connection it is possible that a ForwardClose Request is received
    ** even if IDLE is already left (e.g. in case of re-configuration). So a ForwardClose Request 
    ** is ignored here. 
    */
    case AICSM_k_EVT_PROD_CONN_CLOSED:
    case AICSM_k_EVT_CONS_CONN_CLOSED:       /* fall through */
    {
      /* stay in state */
      break;
    }
    
    /* Abort Request received from ABCC (see [SRS_2244]) */
    case AICSM_k_EVT_ABORT_REQUEST:
    {
      /* switch to ABORT state (see [SRS_2244]) */
      aicSm_eAicState = AICSM_AIC_ABORT;
      break;
    }

    /* invalid/unexpected events are ignored */
    case AICSM_k_EVT_CSS_INIT_RECEIVED:      /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_TUNID:    /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_CONFIG:   /* fall through */
    case AICSM_k_EVT_CSS_INIT_IDLE:          /* fall through */
    case AICSM_k_EVT_CSS_INIT_INVLD_NODEID:  /* fall through */
    case AICSM_k_EVT_TUNID_RECEIVED:         /* fall through */
    case AICSM_k_EVT_CONFIG_RECEIVED:        /* fall through */
    case AICSM_k_EVT_PROD_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_CONS_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_PROD_CONN_FAULTED:      /* fall through */
    case AICSM_k_EVT_CONS_CONN_FAULTED:      /* fall through */
    {
      /* invalid/unexpected state transition, store inside Error Event log,
      ** (see [SRS_2163]) */
      globErrLog_ErrorAdd(GLOBERRLOG_FILE(22u));
      break;
    }
    /* state handler is only called if event != AICSM_k_EVT_NO_EVENT, so this case
    ** should never be reached here.
    */
    case AICSM_k_EVT_NO_EVENT:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(23u));
      break;
    } /* CCT_SKIP */ /* function not called if event == AICSM_k_EVT_NO_EVENT */
    default:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(24u));
      break;
    }
  }
/* This function has a lot of paths because all possible events are catched inside the 
** switch/case. But de facto the function is not really complex. */
/* RSM_IGNORE_QUALITY_BEGIN Notice #28   - Cyclomatic complexity > 15 */
}
/* RSM_IGNORE_QUALITY_END */

/***************************************************************************************************
  Function:
    WaitForConfigState

  Description:
    This function handles the AIC-State "WaitForConfig".

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_t_EVENT, checked)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void WaitForConfigState(AICSM_t_EVENT e_event)
{
  /* evaluate event */
  switch (e_event)
  {
    case AICSM_k_EVT_CONFIG_RECEIVED:
    {
      /* enter next state */
      aicSm_eAicState = AICSM_AIC_PROCESS_CONFIG;
      break;
    }
    /* Safety Reset received (see [SRS_2210]) */
    case AICSM_k_EVT_SAFETY_RESET:
    {
      /* switch to WAIT_RESET state (see [SRS_2210]) */
      aicSm_eAicState = AICSM_AIC_WAIT_RESET;
      break;
    }

    /* Abort Request received from ABCC (see [SRS_2244]) */
    case AICSM_k_EVT_ABORT_REQUEST:
    {
      /* switch to ABORT state (see [SRS_2244]) */
      aicSm_eAicState = AICSM_AIC_ABORT;
      break;
    }

    /* invalid/unexpected events are ignored */
    case AICSM_k_EVT_CSS_INIT_RECEIVED:      /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_TUNID:    /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_CONFIG:   /* fall through */
    case AICSM_k_EVT_CSS_INIT_IDLE:          /* fall through */
    case AICSM_k_EVT_CSS_INIT_INVLD_NODEID:  /* fall through */
    case AICSM_k_EVT_TUNID_RECEIVED:         /* fall through */
    case AICSM_k_EVT_INVLD_CONFIG:           /* fall through */
    case AICSM_k_EVT_CONFIG_DONE:            /* fall through */
    case AICSM_k_EVT_PROD_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_PROD_CONN_CLOSED:       /* fall through */
    case AICSM_k_EVT_CONS_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_CONS_CONN_CLOSED:       /* fall through */
    case AICSM_k_EVT_PROD_CONN_FAULTED:      /* fall through */
    case AICSM_k_EVT_CONS_CONN_FAULTED:      /* fall through */
    {
      /* invalid/unexpected state transition, store inside Error Event log,
      ** (see [SRS_2163]) */
      globErrLog_ErrorAdd(GLOBERRLOG_FILE(25u));
      break;
    }
    /* state handler is only called if event != AICSM_k_EVT_NO_EVENT, so this case
    ** should never be reached here.
    */
    case AICSM_k_EVT_NO_EVENT:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(26u));
      break;
    } /* CCT_SKIP */ /* function not called if event == AICSM_k_EVT_NO_EVENT */
    default:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(27u));
      break;
    }
  }
/* This function has a lot of paths because all possible events are catched inside the 
** switch/case. But de facto the function is not really complex. */
/* RSM_IGNORE_QUALITY_BEGIN Notice #28   - Cyclomatic complexity > 15 */
}
/* RSM_IGNORE_QUALITY_END */

/***************************************************************************************************
  Function:
    InvalidConfigState

  Description:
    This function handles the AIC-State "InvalidConfig".

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_t_EVENT, checked)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void InvalidConfigState(AICSM_t_EVENT e_event)
{
  /* evaluate event */
  switch (e_event)
  {
    case AICSM_k_EVT_CONFIG_RECEIVED:
    {
      /* enter next state */
      aicSm_eAicState = AICSM_AIC_PROCESS_CONFIG;
      break;
    }
    /* Safety Reset received (see [SRS_2210]) */
    case AICSM_k_EVT_SAFETY_RESET:
    {
      /* switch to WAIT_RESET state (see [SRS_2210]) */
      aicSm_eAicState = AICSM_AIC_WAIT_RESET;
      break;
    }
    
    /* In case of a faulted connection it is possible that a ForwardClose Request is received
    ** even if IDLE is already left (e.g. in case of re-configuration). So a ForwardClose Request 
    ** is ignored here. 
    */
    case AICSM_k_EVT_PROD_CONN_CLOSED:
    case AICSM_k_EVT_CONS_CONN_CLOSED:       /* fall through */
    {
      /* stay in state */
      break;
    }
    
    /* Abort Request received from ABCC (see [SRS_2244]) */
    case AICSM_k_EVT_ABORT_REQUEST:
    {
      /* switch to ABORT state (see [SRS_2244]) */
      aicSm_eAicState = AICSM_AIC_ABORT;
      break;
    }

    /* invalid/unexpected events are ignored */
    case AICSM_k_EVT_CSS_INIT_RECEIVED:      /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_TUNID:    /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_CONFIG:   /* fall through */
    case AICSM_k_EVT_CSS_INIT_IDLE:          /* fall through */
    case AICSM_k_EVT_CSS_INIT_INVLD_NODEID:  /* fall through */
    case AICSM_k_EVT_TUNID_RECEIVED:         /* fall through */
    case AICSM_k_EVT_INVLD_CONFIG:           /* fall through */
    case AICSM_k_EVT_CONFIG_DONE:            /* fall through */
    case AICSM_k_EVT_PROD_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_CONS_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_PROD_CONN_FAULTED:      /* fall through */
    case AICSM_k_EVT_CONS_CONN_FAULTED:      /* fall through */
    {
      /* invalid/unexpected state transition, store inside Error Event log,
      ** (see [SRS_2163]) */
      globErrLog_ErrorAdd(GLOBERRLOG_FILE(28u));
      break;
    }
    /* state handler is only called if event != AICSM_k_EVT_NO_EVENT, so this case
    ** should never be reached here.
    */
    case AICSM_k_EVT_NO_EVENT:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(29u));
      break;
    } /* CCT_SKIP */ /* function not called if event == AICSM_k_EVT_NO_EVENT */
    default:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(30u));
      break;
    }
  }
/* This function has a lot of paths because all possible events are catched inside the 
** switch/case. But de facto the function is not really complex. */
/* RSM_IGNORE_QUALITY_BEGIN Notice #28   - Cyclomatic complexity > 15 */
}
/* RSM_IGNORE_QUALITY_END */

/***************************************************************************************************
  Function:
    WaitForTunidState

  Description:
    This function handles the AIC-State "WaitTunid".

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_t_EVENT, checked)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void WaitForTunidState(AICSM_t_EVENT e_event)
{
  /* evaluate event */
  switch (e_event)
  {
    /* valid TUNID was set inside NV memory (see [SRS_2198]) */
    case AICSM_k_EVT_TUNID_RECEIVED:
    {
      /* switch to next state (see [SRS_2198])*/
      aicSm_eAicState = AICSM_AIC_WAIT_FOR_CONFIG;
      break;
    }
    /* Safety Reset received (see [SRS_2209]) */
    case AICSM_k_EVT_SAFETY_RESET:
    {
      /* switch to WAIT_RESET state (see [SRS_2209]) */
      aicSm_eAicState = AICSM_AIC_WAIT_RESET;
      break;
    }

    /* Abort Request received from ABCC (see [SRS_2243]) */
    case AICSM_k_EVT_ABORT_REQUEST:
    {
      /* switch to ABORT state (see [SRS_2243]) */
      aicSm_eAicState = AICSM_AIC_ABORT;
      break;
    }

    /* invalid/unexpected events are ignored */
    case AICSM_k_EVT_CSS_INIT_RECEIVED:      /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_TUNID:    /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_CONFIG:   /* fall through */
    case AICSM_k_EVT_CSS_INIT_IDLE:          /* fall through */
    case AICSM_k_EVT_CSS_INIT_INVLD_NODEID:  /* fall through */
    case AICSM_k_EVT_CONFIG_RECEIVED:        /* fall through */
    case AICSM_k_EVT_INVLD_CONFIG:           /* fall through */
    case AICSM_k_EVT_CONFIG_DONE:            /* fall through */
    case AICSM_k_EVT_PROD_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_PROD_CONN_CLOSED:       /* fall through */
    case AICSM_k_EVT_CONS_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_CONS_CONN_CLOSED:       /* fall through */
    case AICSM_k_EVT_PROD_CONN_FAULTED:      /* fall through */
    case AICSM_k_EVT_CONS_CONN_FAULTED:      /* fall through */
    {
      /* invalid/unexpected state transition, store inside Error Event log,
      ** (see [SRS_2163]) */
      globErrLog_ErrorAdd(GLOBERRLOG_FILE(31u));
      break;
    }
    /* state handler is only called if event != AICSM_k_EVT_NO_EVENT, so this case
    ** should never be reached here.
    */
    case AICSM_k_EVT_NO_EVENT:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(32u));
      break;
    } /* CCT_SKIP */ /* function not called if event == AICSM_k_EVT_NO_EVENT */
    default:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(33u));
      break;
    }
  }
/* This function has a lot of paths because all possible events are catched inside the 
** switch/case. But de facto the function is not really complex. */
/* RSM_IGNORE_QUALITY_BEGIN Notice #28   - Cyclomatic complexity > 15 */
}
/* RSM_IGNORE_QUALITY_END */

/***************************************************************************************************
  Function:
    WaitResetState

  Description:
    This function handles the AIC-State "wait for reset". This state is never left since the 
    T100 waits for an external reset.

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_t_EVENT, checked)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void WaitResetState(AICSM_t_EVENT e_event)
{
  /* evaluate event */
  switch (e_event)
  {
    /* In case of a faulted connection it is possible that a ForwardClose Request is received
    ** even if IDLE is already left (e.g. in case of re-configuration). So a ForwardClose Request 
    ** is ignored here. 
    */
    case AICSM_k_EVT_PROD_CONN_CLOSED:
    case AICSM_k_EVT_CONS_CONN_CLOSED:       /* fall through */
    {
      /* stay in state */
      break;
    }
    
    /* invalid/unexpected events are ignored */
    case AICSM_k_EVT_CSS_INIT_RECEIVED:      /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_TUNID:    /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_CONFIG:   /* fall through */
    case AICSM_k_EVT_CSS_INIT_IDLE:          /* fall through */
    case AICSM_k_EVT_CSS_INIT_INVLD_NODEID:  /* fall through */
    case AICSM_k_EVT_TUNID_RECEIVED:         /* fall through */
    case AICSM_k_EVT_CONFIG_RECEIVED:        /* fall through */
    case AICSM_k_EVT_INVLD_CONFIG:           /* fall through */
    case AICSM_k_EVT_CONFIG_DONE:            /* fall through */
    case AICSM_k_EVT_PROD_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_CONS_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_PROD_CONN_FAULTED:      /* fall through */
    case AICSM_k_EVT_CONS_CONN_FAULTED:      /* fall through */
    case AICSM_k_EVT_SAFETY_RESET:           /* fall through */
    case AICSM_k_EVT_ABORT_REQUEST:          /* fall through */
    {
      /* invalid/unexpected state transition, store inside Error Event log,
      ** (see [SRS_2163]) */
      globErrLog_ErrorAdd(GLOBERRLOG_FILE(34u));
      break;
    }
    /* state handler is only called if event != AICSM_k_EVT_NO_EVENT, so this case
    ** should never be reached here.
    */
    case AICSM_k_EVT_NO_EVENT:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(35u));
      break;
    } /* CCT_SKIP */ /* function not called if event == AICSM_k_EVT_NO_EVENT */
    default:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(36u));
      break;
    }
  }
/* This function has a lot of paths because all possible events are catched inside the 
** switch/case. But de facto the function is not really complex. */
/* RSM_IGNORE_QUALITY_BEGIN Notice #28   - Cyclomatic complexity > 15 */
}
/* RSM_IGNORE_QUALITY_END */

/***************************************************************************************************
  Function:
    AbortState

  Description:
    This function handles the AIC-State "Abort".

  See also:
    -

  Parameters:
    e_event (IN)   - Event triggered by IRQ scheduler or Background Task.
                     (valid range: see AICSM_t_EVENT, checked)

  Return value:
    -

  Remarks:
    -

***************************************************************************************************/
STATIC void AbortState(AICSM_t_EVENT e_event)
{
  /* evaluate event */
  switch (e_event)
  {
    /* Safety Reset received (see [SRS_2212]) */
    case AICSM_k_EVT_SAFETY_RESET:
    {
      /* switch to WAIT_RESET state (see [SRS_2212]) */
      aicSm_eAicState = AICSM_AIC_WAIT_RESET;
      break;
    }

    /* Ignore ForwardClose or 'Fault' events in ABORT state */
    case AICSM_k_EVT_PROD_CONN_CLOSED:       /* fall through */
    case AICSM_k_EVT_CONS_CONN_CLOSED:       /* fall through */
    case AICSM_k_EVT_PROD_CONN_FAULTED:      /* fall through */
    case AICSM_k_EVT_CONS_CONN_FAULTED:      /* fall through */
    {
      break;
    }

    /* invalid/unexpected events are ignored */
    case AICSM_k_EVT_CSS_INIT_RECEIVED:      /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_TUNID:    /* fall through */
    case AICSM_k_EVT_CSS_INIT_WAIT_CONFIG:   /* fall through */
    case AICSM_k_EVT_CSS_INIT_IDLE:          /* fall through */
    case AICSM_k_EVT_CSS_INIT_INVLD_NODEID:  /* fall through */
    case AICSM_k_EVT_TUNID_RECEIVED:         /* fall through */
    case AICSM_k_EVT_CONFIG_RECEIVED:        /* fall through */
    case AICSM_k_EVT_INVLD_CONFIG:           /* fall through */
    case AICSM_k_EVT_CONFIG_DONE:            /* fall through */
    case AICSM_k_EVT_PROD_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_CONS_CONN_ESTABLISHED:  /* fall through */
    case AICSM_k_EVT_ABORT_REQUEST:          /* fall through */
    {
      /* invalid/unexpected state transition, store inside Error Event log,
      ** (see [SRS_2163]) */
      globErrLog_ErrorAdd(GLOBERRLOG_FILE(37u));
      break;
    }
    /* state handler is only called if event != AICSM_k_EVT_NO_EVENT, so this case
    ** should never be reached here.
    */
    case AICSM_k_EVT_NO_EVENT:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(38u));
      break;
    } /* CCT_SKIP */ /* function not called if event == AICSM_k_EVT_NO_EVENT */
    default:
    {
      GLOBFAIL_SAFETY_HANDLER(GLOB_FAILCODE_VARIABLE_ERR_EX, GLOBFAIL_ADDINFO_FILE(39u));
      break;
    }
  }
/* This function has a lot of paths because all possible events are catched inside the 
** switch/case. But de facto the function is not really complex. */
/* RSM_IGNORE_QUALITY_BEGIN Notice #28   - Cyclomatic complexity > 15 */
}
/* RSM_IGNORE_QUALITY_END */
